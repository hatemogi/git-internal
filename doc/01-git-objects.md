# Git 내부 구조를 알아보자 : 1부 - 저장소 내부 맛보기

안녕하세요, 김대현입니다. Git 내부 구조를 알아보자는 내용으로 글과 스크린캐스트를 찍어 올리고 있습니다. 이 프로젝트의 소개나, 왜 이걸 하는지, 그리고 이게 무엇에 도움이 될지는 이전 글이나 동영상에서 설명한 내용을 참고해 주세요.

* [미디엄 글: Git 내부 구조를 알아보자 (0) 프로젝트 소개와 예고](https://medium.com/happyprogrammer-in-jeju/git-내부-구조를-알아보자-0-프로젝트-소개와-예고-bf3a8549f439)
* [유튜브 동영상: Git 내부 구조를 알아보자 (0) 예고](https://youtu.be/DWnrsbxhuOY)

이번 편, 1부에서는 Git 내부에 저장되는 오브젝트들의 종류를 전반적으로 살펴보고 어떻게 쓰이는지 간략히 알아보겠습니다. 1부에서는 전체적으로 빠르게 훑어보고, 2부부터 자세히 더 깊게 파고들어 설명할 예정입니다.

## Git 저장소 디렉터리의 내용

아시다시피 Git은 분산 버전 관리 시스템이고, 한 프로젝트의 여러 저장소가 각각 독립적으로 완전한 데이터를 갖고 있을 수 있습니다. 원격 저장소 없이 로컬 저장소만으로도 버전 관리를 할 수도 있지요.

지금부터 로컬에 직접 저장소를 하나 새로 만들어서 진행하겠습니다. Git을 써보신 분들은 대략 아시는 내용이겠습니다.

``` bash
$ git --version
$ mkdir 저장소 && cd 저장소
$ ls -A
$ git init
$ ls -A
$ ls -p1 .git
HEAD
config
description
hooks/
info/
objects/
refs/
$ tree -a
$ find .
```

이렇게 새로 git 저장소를 만들면, 작업 디렉터리 아래에 .git/ 디렉터리가 생기고, 이 안에 git 저장소의 모든 내역이 담기게 됩니다. 그리고, 이 내용을 바탕으로, 원격 저장소와 연결하지 않고도, git의 모든 작업을 할 수 있습니다. 각각의 파일이나 디렉터리의 역할과 내용은 차차 설명하기로 하고 우선은 이렇게 생겼다고만 알고 넘어갈게요.

지금 막 `git init`로 초기화 했지만, 아직 별다른 내용도 들어 있지 않은 최초 상태입니다. 차근차근 어떤 내용이 어디에 들어가는지 파헤쳐 볼게요.

## README.md 파일을 추가해 봅시다.

방금 만든 빈 저장소에 새로 파일을 하나 추가합니다.

``` bash
$ echo '# 실험용 저장소' > READㅅ첫ME.md
$ git status
$ git add README.md
$ git status
$ tree -a
```

아직 커밋은 하지 않았고, 인덱스 영역에 새로 만든 `README.md`파일이 들어갔습니다. 이 상황에 저장소 디렉터리를 보면, `.git/objects/8a/8363d93e61185f6df18ed61321626be514c7f4` 파일이 새로 생겼다는 점이 눈에 띕니다. 저 암호같은 파일명은 뭘까요?

## Git 기본: SHA-1 해시

Git은 데이터를 저장하기 전에 항상 체크섬을 구하고 그 기준으로 데이터를 관리합니다. 그 체크섬을 구하는데 SHA-1 해시를 사용하고, 그러면 체크섬은 160bit가 되고, 이를 16진수 문자열 형태로 표현하면 40글자가 됩니다.

> 8a8363d93e61185f6df18ed61321626be514c7f4

이런 식으로요. Git은 모든 것을 해시로 식별하기에 이런 문자열은 여기저기서 보입니다. 저장소에 보관하는 파일도 이 체크섬을 키값으로 보관하고, 전체 트리(디렉터리)도 이 체크섬으로 보관하며, 커밋에 대한 데이터도 이 체크섬 기준으로 보관합니다.

이 40글자로 표현하면, "거의" 온세상에서 유일한 값이 나오므로, 고유 키값으로 쓸 수 있습니다. 그리고 찾고자 하는 범위를 "한 저장소 안"으로 좁히면, 앞의 몇 글자만 써도 고유하기에, 여덟 자나 열 자로만 줄여서 쓸 수도 있습니다.

예를 들어, 위 `8a8363d93e61185f6df18ed61321626be514c7f4`을 git 명령어를 쓸 때는 `8a8363`처럼 앞 몇 글자만 적어도 됩니다. github.com의 경우, 글을 쓰는 현재, 화면에는 앞의 7자만 화면에 보여주고 있습니다. (실제 링크는 40자 전체로 걸려 있습니다)

즉, 아래 두 명령어는 같은 효과를 냅니다.

``` bash
$ git show 8a8363d93e61185f6df18ed61321626be514c7f4
$ git show 8a8363
```

## Git 기본: Content-addressable Key-Value Storage

Git이 내용을 주소로 활용하는 파일시스템(content-addressable filesystem)이라는 얘기를 들어보셨을 지도 모르겠습니다. Git의 내부는 사실 꽤 단순한(man 페이지에 보면 stupid로 표현하고 있습니다) 키-값 데이터베이스입니다. 어떤 데이터든 Git에 담을 수 있고, Git은 그 데이터의 SHA1 해시값을 키값으로 해서 저장합니다. 그러면 나중에 다시 그 SHA1 값으로 보관했던 데이터를 찾을 수 있지요. 이 단순한 키-값 스토리지 위에 몇 가지 방식으로 데이터를 담고, 그걸 잘 가져다 활용해서, 결국 겉으로 보기에는 버전 관리 시스템을 쓸 수 있게 됩니다.

그냥 평소 우리가 Git을 사용할 때는, 보통의 Git 명령어나 API로 버전 관리 시스템을 썼지만, 이 연재에서는 그 아래에 있는 키-값 스토리지가 어떻게 쓰이는지 알아보는 것이죠.

## Plumbing & Porcelain

## Zlib

http://www.zlib.net

## blob 추가

``` bash
$ echo '# 실험용 저장소' > README.md
$ find .git
$ cat README.md | git hash-object --stdin
$ find .git
$ cat README.md | git hash-object -w --stdin
$ ruby -rzlib -e 'print Zlib::Inflate.inflate(STDIN.read)' < .git/objects/8a/8363d93e61185f6df18ed61321626be514c7f4
blob 22# 실험용 저장소
$ ruby -rzlib -e 'p Zlib::Inflate.inflate(STDIN.read)' < .git/objects/8a/8363d93e61185f6df18ed61321626be514c7f4
"blob 22\x00# \xEC\x8B\xA4\xED\x97\x98\xEC\x9A\xA9 \xEC\xA0\x80\xEC\x9E\xA5\xEC\x86\x8C\n"
```

## Git 커밋, 브랜치, 그리고 HEAD 리뷰

먼저, Git 사용하시면서 잘 알게된 내용이실 텐데, Git 내부를 파헤치는 관점으로 다시 한 번 훑어보겠습니다. Git의 커밋 각각의 순간 프로젝트의 스냅샷을 담을 수 있지요. 커밋할 때의 전체 디렉터리 내용이 다 들어있습니다. 그리고 브랜치는 그 커밋들 중 하나를 가르키고 있는 포인터입니다.

## Git 저장소가 하는 일





## JGit 소개

JVM 기반의 현대적 리스프로 불리는 Clojure는 Java 라이브러리를 그대로 가져다 쓸 수 있기에, JGit이라는 훌륭하고 탄탄한 Git 제어용 라이브러리를 쓰면 관련한 모든 일이든 할 수 있습니다. 그런데, Git 내부에 대해 아직 익숙하지 않기 때문인지, API 문서를 봐도 잘 이해가 되지 않고, 어떤 메소드를 어떻게 불러야할지 잘 모르겠더군요.

오래전에 공식 Git 사이트에 있는 문서로 Git 내부 구조를 공부한 적이 있어, 어렴풋이 어떻게 저장되는지 감은 잡고 있지만, 아직 뿌연 안개 속에 있는 기분이다. 이참에 다시 문서를 파헤쳐보며 연습용 코드를 작성해 봐야겠다. 그리고 이왕하는거, JGit을 불러다 쓰는 것도 좋지만, 그냥 순수(!) 클로저로 작성해보면 재밌겠다는 욕심까지 든다.

Git은 content-addressable 파일시스템(파일 내용을 주소로 활용)이다. Git의 내부는 그저 단순한 키-값 저장소일 뿐이며, 사실상 어떤 종류의 데이터도 저장할 수 있다. Git에 데이터를 저장하면, 내용에 해당하는 키값을 돌려주며, 이 키를 써서 나중에 해당 데이터를 언제라도 찾아올 수 있다.
